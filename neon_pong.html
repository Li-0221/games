<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>霓虹乒乓</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      body {
        background-color: #020617; /* Slate 950 */
        font-family: "Press Start 2P", cursive;
        touch-action: none;
        overflow: hidden;
      }

      canvas {
        box-shadow: 0 0 30px rgba(217, 70, 239, 0.2);
        background-color: #0f172a; /* Slate 900 */
        border: 2px solid #334155;
      }

      .neon-text {
        text-shadow: 0 0 5px currentColor;
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col items-center justify-center relative text-white"
  >
    <!-- 计分板 -->
    <div
      class="absolute top-8 w-full flex justify-center gap-12 z-10 pointer-events-none"
    >
      <div class="text-center">
        <p class="text-xs text-cyan-400 mb-2">PLAYER</p>
        <p id="playerScore" class="text-4xl text-white neon-text">0</p>
      </div>
      <div class="text-center">
        <p class="text-xs text-fuchsia-400 mb-2">CPU</p>
        <p id="cpuScore" class="text-4xl text-white neon-text">0</p>
      </div>
    </div>

    <!-- 游戏画布 -->
    <div class="relative">
      <canvas id="gameCanvas"></canvas>

      <!-- 开始遮罩 -->
      <div
        id="overlay"
        class="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center z-20"
      >
        <h1
          class="text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-400 mb-6 neon-text"
          style="text-shadow: 0 0 20px rgba(217, 70, 239, 0.5)"
        >
          NEON PONG
        </h1>
        <p class="text-xs text-slate-400 mb-8">拖动屏幕移动挡板</p>
        <button
          id="startBtn"
          class="px-8 py-3 border-2 border-cyan-500 text-cyan-400 hover:bg-cyan-500 hover:text-slate-900 transition-all text-sm rounded shadow-[0_0_15px_rgba(6,182,212,0.4)]"
        >
          START GAME
        </button>
      </div>
    </div>

    <div class="absolute bottom-4 text-[10px] text-slate-600">
      Made for Neon Arcade
    </div>

    <script>
      // 使用立即执行函数 (IIFE) 隔离作用域，防止全局变量冲突
      (function () {
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const playerScoreEl = document.getElementById("playerScore");
        const cpuScoreEl = document.getElementById("cpuScore");
        const overlay = document.getElementById("overlay");
        const startBtn = document.getElementById("startBtn");

        // 响应式调整
        let w, h;
        function resize() {
          w = Math.min(window.innerWidth - 20, 600);
          h = Math.min(window.innerHeight - 100, 400);
          // 保持一定的纵横比
          canvas.width = w;
          canvas.height = h;

          // 重置挡板位置
          if (typeof player !== "undefined") {
            player.y = h / 2 - paddleHeight / 2;
            cpu.y = h / 2 - paddleHeight / 2;
          }
        }
        window.addEventListener("resize", resize);

        // 游戏参数
        const paddleWidth = 10;
        const paddleHeight = 60;
        const ballSize = 8;
        let isRunning = false;
        let animationId;

        // 对象定义
        const player = { x: 0, y: 0, score: 0, color: "#22d3ee" }; // Cyan
        const cpu = { x: 0, y: 0, score: 0, speed: 4, color: "#e879f9" }; // Fuchsia
        const ball = { x: 0, y: 0, dx: 0, dy: 0, speed: 5, color: "#ffffff" };

        // 初始化
        resize();
        resetGame();

        function resetGame() {
          player.x = 10;
          player.y = h / 2 - paddleHeight / 2;
          cpu.x = w - 10 - paddleWidth;
          cpu.y = h / 2 - paddleHeight / 2;
          resetBall();
        }

        function resetBall() {
          ball.x = w / 2;
          ball.y = h / 2;
          ball.speed = 5;
          // 随机发球方向
          ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
          ball.dy = (Math.random() * 2 - 1) * ball.speed;
        }

        // 输入控制 (鼠标 & 触摸)
        function movePaddle(clientY) {
          const rect = canvas.getBoundingClientRect();
          const relativeY = clientY - rect.top;
          // 限制在画布内
          let nextY = relativeY - paddleHeight / 2;
          if (nextY < 0) nextY = 0;
          if (nextY + paddleHeight > h) nextY = h - paddleHeight;
          player.y = nextY;
        }

        canvas.addEventListener("mousemove", (e) => {
          if (isRunning) movePaddle(e.clientY);
        });

        canvas.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            if (isRunning) movePaddle(e.touches[0].clientY);
          },
          { passive: false }
        );

        // 游戏循环
        function update() {
          if (!isRunning) return;

          // 1. 移动球
          ball.x += ball.dx;
          ball.y += ball.dy;

          // 2. 墙壁碰撞 (上下)
          if (ball.y - ballSize / 2 < 0 || ball.y + ballSize / 2 > h) {
            ball.dy *= -1;
            playTone(200, "square");
          }

          // 3. 挡板碰撞
          // 检测玩家
          let playerCollide =
            ball.x - ballSize / 2 < player.x + paddleWidth &&
            ball.y > player.y &&
            ball.y < player.y + paddleHeight;

          // 检测CPU
          let cpuCollide =
            ball.x + ballSize / 2 > cpu.x &&
            ball.y > cpu.y &&
            ball.y < cpu.y + paddleHeight;

          if (playerCollide) {
            // 计算击球点，改变反弹角度
            let collidePoint = ball.y - (player.y + paddleHeight / 2);
            collidePoint = collidePoint / (paddleHeight / 2);

            let angleRad = (Math.PI / 4) * collidePoint;

            // 稍微加速
            if (ball.speed < 12) ball.speed += 0.5;

            let direction = ball.x < w / 2 ? 1 : -1;
            ball.dx = direction * ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);

            playTone(400, "sine");
          } else if (cpuCollide) {
            let collidePoint = ball.y - (cpu.y + paddleHeight / 2);
            collidePoint = collidePoint / (paddleHeight / 2);
            let angleRad = (Math.PI / 4) * collidePoint;

            if (ball.speed < 12) ball.speed += 0.5;

            let direction = -1;
            ball.dx = direction * ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);

            playTone(400, "sine");
          }

          // 4. 得分检测
          if (ball.x < 0) {
            cpu.score++;
            cpuScoreEl.innerText = cpu.score;
            playTone(100, "sawtooth");
            resetBall();
          } else if (ball.x > w) {
            player.score++;
            playerScoreEl.innerText = player.score;
            playTone(600, "sine");
            resetBall();
          }

          // 5. CPU AI
          // 简单的追踪逻辑 + 延迟
          const cpuCenter = cpu.y + paddleHeight / 2;
          if (cpuCenter < ball.y - 10) {
            cpu.y += cpu.speed;
          } else if (cpuCenter > ball.y + 10) {
            cpu.y -= cpu.speed;
          }
          // CPU边界限制
          if (cpu.y < 0) cpu.y = 0;
          if (cpu.y + paddleHeight > h) cpu.y = h - paddleHeight;
        }

        function draw() {
          // 清空
          ctx.fillStyle = "#0f172a";
          ctx.fillRect(0, 0, w, h);

          // 中线
          ctx.strokeStyle = "#1e293b";
          ctx.setLineDash([10, 10]);
          ctx.beginPath();
          ctx.moveTo(w / 2, 0);
          ctx.lineTo(w / 2, h);
          ctx.stroke();
          ctx.setLineDash([]);

          // 绘制挡板
          ctx.fillStyle = player.color;
          ctx.shadowBlur = 15;
          ctx.shadowColor = player.color;
          ctx.fillRect(player.x, player.y, paddleWidth, paddleHeight);

          ctx.fillStyle = cpu.color;
          ctx.shadowColor = cpu.color;
          ctx.fillRect(cpu.x, cpu.y, paddleWidth, paddleHeight);

          // 绘制球
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ballSize, 0, Math.PI * 2);
          ctx.fillStyle = ball.color;
          ctx.shadowColor = ball.color;
          ctx.fill();
          ctx.closePath();

          ctx.shadowBlur = 0;
        }

        function loop() {
          update();
          draw();
          if (isRunning) animationId = requestAnimationFrame(loop);
        }

        // 音效
        const audioCtx = new (window.AudioContext ||
          window.webkitAudioContext)();
        function playTone(freq, type) {
          if (audioCtx.state === "suspended") audioCtx.resume();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.1
          );
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        }

        // 开始按钮
        startBtn.addEventListener("click", () => {
          overlay.classList.add("hidden");
          isRunning = true;
          resetGame();
          loop();
        });
      })(); // IIFE 结束
    </script>
  </body>
</html>
