<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>霓虹贪吃蛇</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      body {
        background-color: #0f172a; /* Slate 900 */
        font-family: "Press Start 2P", cursive; /* 像素风格字体 */
        touch-action: none; /* 防止手机端滚动 */
        overflow: hidden;
      }

      /* 霓虹发光效果 */
      .neon-text {
        text-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80;
      }

      canvas {
        box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
        background-color: #1e293b; /* Slate 800 */
        border: 2px solid #334155;
        image-rendering: pixelated;
      }

      /* 虚拟按键样式 */
      .d-pad-btn {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        active: scale(0.95);
        transition: all 0.1s;
        user-select: none;
        -webkit-user-select: none;
      }
      .d-pad-btn:active {
        background: rgba(74, 222, 128, 0.4);
        transform: scale(0.95);
      }

      /* 游戏结束遮罩层动画 */
      .fade-in {
        animation: fadeIn 0.3s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col items-center justify-center text-white relative"
  >
    <!-- 顶部计分板 -->
    <div
      class="w-full max-w-md flex justify-between px-6 mb-4 text-sm sm:text-base z-10"
    >
      <div class="flex flex-col items-start">
        <span class="text-slate-400 text-xs mb-1">分数</span>
        <span id="scoreEl" class="text-green-400 text-xl">0</span>
      </div>
      <div class="flex flex-col items-end">
        <span class="text-slate-400 text-xs mb-1">最高分</span>
        <span id="highScoreEl" class="text-purple-400 text-xl">0</span>
      </div>
    </div>

    <!-- 游戏画布容器 -->
    <div class="relative z-0">
      <canvas
        id="gameCanvas"
        width="400"
        height="400"
        class="rounded-lg max-w-[95vw] max-h-[60vh]"
      ></canvas>

      <!-- 开始/游戏结束 遮罩层 -->
      <div
        id="overlay"
        class="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center rounded-lg z-20 fade-in"
      >
        <h1
          class="text-3xl sm:text-4xl text-green-400 mb-2 tracking-wider neon-text text-center leading-snug"
        >
          SNAKE<br /><span class="text-sm text-white" style="text-shadow: none"
            >霓虹贪吃蛇</span
          >
        </h1>
        <p id="finalScoreLabel" class="text-sm text-slate-300 mt-4 hidden">
          最终得分: <span id="finalScoreVal" class="text-white">0</span>
        </p>
        <button
          id="startBtn"
          class="mt-8 px-8 py-4 bg-green-500 hover:bg-green-600 text-slate-900 font-bold rounded shadow-[0_0_15px_rgba(34,197,94,0.5)] transition-all transform hover:scale-105 active:scale-95 text-sm"
        >
          开始游戏
        </button>
        <p class="mt-4 text-[10px] text-slate-500">
          电脑使用方向键 | 手机使用触屏
        </p>
      </div>
    </div>

    <!-- 手机端虚拟控制器 (仅在小屏幕显示) -->
    <div class="mt-6 grid grid-cols-3 gap-2 sm:hidden w-48 h-32 z-10">
      <div></div>
      <button
        class="d-pad-btn rounded-t-lg flex items-center justify-center"
        data-dir="up"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          class="h-8 w-8 text-white"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M5 10l7-7m0 0l7 7m-7-7v18"
          />
        </svg>
      </button>
      <div></div>

      <button
        class="d-pad-btn rounded-l-lg flex items-center justify-center"
        data-dir="left"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          class="h-8 w-8 text-white"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M10 19l-7-7m0 0l7-7m-7 7h18"
          />
        </svg>
      </button>
      <button
        class="d-pad-btn rounded-lg flex items-center justify-center"
        data-dir="down"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          class="h-8 w-8 text-white"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M19 14l-7 7m0 0l-7-7m7 7V3"
          />
        </svg>
      </button>
      <button
        class="d-pad-btn rounded-r-lg flex items-center justify-center"
        data-dir="right"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          class="h-8 w-8 text-white"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M14 5l7 7m0 0l-7 7m7-7H3"
          />
        </svg>
      </button>
    </div>

    <script>
      // === 游戏配置 ===
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("scoreEl");
      const highScoreEl = document.getElementById("highScoreEl");
      const overlay = document.getElementById("overlay");
      const startBtn = document.getElementById("startBtn");
      const finalScoreLabel = document.getElementById("finalScoreLabel");
      const finalScoreVal = document.getElementById("finalScoreVal");

      // 响应式画布大小调整
      function resizeCanvas() {
        // 保持正方形，最大 400px
        let size = Math.min(
          window.innerWidth - 30,
          window.innerHeight - 250,
          400
        );
        // 确保 size 是 gridCount 的倍数 (20)
        size = Math.floor(size / 20) * 20;
        if (size < 280) size = 280; // 最小尺寸

        canvas.style.width = size + "px";
        canvas.style.height = size + "px";
        // 内部分辨率保持 400x400 以简化逻辑，通过 CSS 缩放
        canvas.width = 400;
        canvas.height = 400;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // 游戏参数
      const gridSize = 20;
      const tileCount = 20; // 400 / 20
      let speed = 3; // 每秒帧数
      let score = 0;
      let highScore = localStorage.getItem("snakeHighScore") || 0;
      highScoreEl.innerText = highScore;

      let gameInterval;
      let isGameRunning = false;

      // 蛇的状态
      let snake = [];
      let dx = 0;
      let dy = 0;
      let nextDx = 0; // 缓冲输入，防止按键过快导致自杀
      let nextDy = 0;

      // 食物状态
      let food = { x: 10, y: 10 };

      // 音效 (简单的 Web Audio API，避免加载外部文件)
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioContext();

      function playSound(type) {
        if (audioCtx.state === "suspended") audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === "eat") {
          osc.type = "sine";
          osc.frequency.setValueAtTime(600, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            1000,
            audioCtx.currentTime + 0.1
          );
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.1
          );
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === "die") {
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(200, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            50,
            audioCtx.currentTime + 0.3
          );
          gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.3
          );
          osc.start();
          osc.stop(audioCtx.currentTime + 0.3);
        }
      }

      // === 游戏逻辑 ===

      function initGame() {
        snake = [
          { x: 10, y: 10 },
          { x: 9, y: 10 },
          { x: 8, y: 10 }
        ]; // 初始蛇身
        dx = 1; // 向右移动
        dy = 0;
        nextDx = 1;
        nextDy = 0;
        score = 0;
        speed = 3; // 重置速度
        scoreEl.innerText = score;
        createFood();

        if (gameInterval) clearInterval(gameInterval);
        isGameRunning = true;
        overlay.classList.add("hidden");

        gameInterval = setInterval(gameLoop, 1000 / speed);
      }

      function gameLoop() {
        update();
        draw();
      }

      function update() {
        // 更新实际方向
        dx = nextDx;
        dy = nextDy;

        const head = { x: snake[0].x + dx, y: snake[0].y + dy };

        // 撞墙检测
        if (
          head.x < 0 ||
          head.x >= tileCount ||
          head.y < 0 ||
          head.y >= tileCount
        ) {
          gameOver();
          return;
        }

        // 撞身体检测
        for (let i = 0; i < snake.length; i++) {
          if (head.x === snake[i].x && head.y === snake[i].y) {
            gameOver();
            return;
          }
        }

        snake.unshift(head); // 头部增加

        // 吃食物
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          scoreEl.innerText = score;
          playSound("eat");

          // === 速度升级逻辑 ===
          // 每吃一个食物，速度增加 0.3 (上限 25)
          if (speed < 25) {
            speed += 0.3;
            clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, 1000 / speed);
          }

          // 更新最高分
          if (score > highScore) {
            highScore = score;
            highScoreEl.innerText = highScore;
            localStorage.setItem("snakeHighScore", highScore);
          }

          createFood();
        } else {
          snake.pop(); // 如果没吃到，尾部移除
        }
      }

      function createFood() {
        // 随机生成食物，且不能在蛇身上
        let valid = false;
        while (!valid) {
          food.x = Math.floor(Math.random() * tileCount);
          food.y = Math.floor(Math.random() * tileCount);

          valid = true;
          for (let part of snake) {
            if (part.x === food.x && part.y === food.y) {
              valid = false;
              break;
            }
          }
        }
      }

      function gameOver() {
        isGameRunning = false;
        clearInterval(gameInterval);
        playSound("die");

        finalScoreVal.innerText = score;
        finalScoreLabel.classList.remove("hidden");
        startBtn.innerText = "重新开始";
        overlay.classList.remove("hidden");
      }

      // === 渲染逻辑 ===

      function draw() {
        // 清空画布
        ctx.fillStyle = "#1e293b"; // 背景色
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 绘制网格 (可选，增加科技感)
        ctx.strokeStyle = "#334155";
        ctx.lineWidth = 0.5;
        // for (let i = 0; i < tileCount; i++) {
        //     ctx.beginPath();
        //     ctx.moveTo(i * gridSize, 0);
        //     ctx.lineTo(i * gridSize, canvas.height);
        //     ctx.stroke();
        //     ctx.beginPath();
        //     ctx.moveTo(0, i * gridSize);
        //     ctx.lineTo(canvas.width, i * gridSize);
        //     ctx.stroke();
        // }

        // 绘制食物
        // 呼吸效果
        const glowSize = 10 + Math.sin(Date.now() / 200) * 5;
        ctx.fillStyle = "#f472b6"; // 粉色食物
        ctx.shadowBlur = glowSize;
        ctx.shadowColor = "#f472b6";
        ctx.fillRect(
          food.x * gridSize + 2,
          food.y * gridSize + 2,
          gridSize - 4,
          gridSize - 4
        );
        ctx.shadowBlur = 0; // 重置阴影以免影响蛇

        // 绘制蛇
        for (let i = 0; i < snake.length; i++) {
          // 头部
          if (i === 0) {
            ctx.fillStyle = "#4ade80"; // 亮绿色
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#4ade80";
          } else {
            // 身体渐变
            ctx.fillStyle = "#22c55e"; // 普通绿色
            ctx.shadowBlur = 0;
          }

          ctx.fillRect(
            snake[i].x * gridSize + 1,
            snake[i].y * gridSize + 1,
            gridSize - 2,
            gridSize - 2
          );

          // 绘制眼睛 (如果是头部)
          if (i === 0) {
            ctx.fillStyle = "#000";
            // 根据方向简单画眼睛
            let eyeOffsetX = 0,
              eyeOffsetY = 0;
            // 简化处理，不做复杂转向判断
            ctx.fillRect(
              snake[i].x * gridSize + 4,
              snake[i].y * gridSize + 4,
              4,
              4
            );
            ctx.fillRect(
              snake[i].x * gridSize + 12,
              snake[i].y * gridSize + 4,
              4,
              4
            );
          }
        }
        ctx.shadowBlur = 0;
      }

      // === 输入处理 ===

      // 键盘控制
      document.addEventListener("keydown", (e) => {
        if (!isGameRunning) return;

        const key = e.key;

        // 防止反向移动和快速按键冲突
        if ((key === "ArrowUp" || key === "w" || key === "W") && dy === 0) {
          nextDx = 0;
          nextDy = -1;
        } else if (
          (key === "ArrowDown" || key === "s" || key === "S") &&
          dy === 0
        ) {
          nextDx = 0;
          nextDy = 1;
        } else if (
          (key === "ArrowLeft" || key === "a" || key === "A") &&
          dx === 0
        ) {
          nextDx = -1;
          nextDy = 0;
        } else if (
          (key === "ArrowRight" || key === "d" || key === "D") &&
          dx === 0
        ) {
          nextDx = 1;
          nextDy = 0;
        }
      });

      // 手机虚拟按键控制
      const dpadButtons = document.querySelectorAll(".d-pad-btn");
      dpadButtons.forEach((btn) => {
        // 支持触摸和鼠标点击
        const handleInput = (e) => {
          e.preventDefault(); // 防止触发其他事件
          if (!isGameRunning) return;

          const dir = btn.dataset.dir;
          if (dir === "up" && dy === 0) {
            nextDx = 0;
            nextDy = -1;
          } else if (dir === "down" && dy === 0) {
            nextDx = 0;
            nextDy = 1;
          } else if (dir === "left" && dx === 0) {
            nextDx = -1;
            nextDy = 0;
          } else if (dir === "right" && dx === 0) {
            nextDx = 1;
            nextDy = 0;
          }
        };

        btn.addEventListener("touchstart", handleInput);
        btn.addEventListener("mousedown", handleInput);
      });

      // 开始按钮
      startBtn.addEventListener("click", initGame);
    </script>
  </body>
</html>
