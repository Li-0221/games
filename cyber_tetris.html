<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>赛博朋克俄罗斯方块</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap");

      body {
        background-color: #09090b; /* Zinc 950 */
        font-family: "Orbitron", sans-serif;
        color: #e4e4e7;
        touch-action: none;
        overflow: hidden;
      }

      /* 霓虹发光边框 */
      .neon-border {
        box-shadow: 0 0 10px rgba(6, 182, 212, 0.5),
          inset 0 0 5px rgba(6, 182, 212, 0.2);
        border: 2px solid #06b6d4;
      }

      /* 游戏画布 */
      canvas {
        image-rendering: pixelated;
      }

      /* 按钮样式 */
      .control-btn {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(4px);
        border-radius: 12px;
        touch-action: manipulation;
        transition: all 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        -webkit-user-select: none;
        cursor: pointer;
      }
      .control-btn:active {
        background: rgba(6, 182, 212, 0.3);
        transform: scale(0.95);
        box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        border-color: #06b6d4;
      }

      .btn-icon {
        width: 32px;
        height: 32px;
        fill: currentColor;
      }

      /* 动画类 */
      @keyframes shake {
        0% {
          transform: translate(1px, 1px) rotate(0deg);
        }
        10% {
          transform: translate(-1px, -2px) rotate(-1deg);
        }
        20% {
          transform: translate(-3px, 0px) rotate(1deg);
        }
        30% {
          transform: translate(3px, 2px) rotate(0deg);
        }
        40% {
          transform: translate(1px, -1px) rotate(1deg);
        }
        50% {
          transform: translate(-1px, 2px) rotate(-1deg);
        }
        60% {
          transform: translate(-3px, 1px) rotate(0deg);
        }
        70% {
          transform: translate(3px, 1px) rotate(-1deg);
        }
        80% {
          transform: translate(-1px, -1px) rotate(1deg);
        }
        90% {
          transform: translate(1px, 2px) rotate(0deg);
        }
        100% {
          transform: translate(1px, -2px) rotate(-1deg);
        }
      }
      .shake-screen {
        animation: shake 0.3s;
        animation-iteration-count: 1;
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col items-center justify-center relative"
  >
    <!-- 主游戏区域容器 -->
    <div
      id="gameContainer"
      class="flex flex-col md:flex-row items-center justify-center gap-4 md:gap-8 w-full max-w-4xl p-4 z-10"
    >
      <!-- 左侧信息栏 (电脑端左侧，手机端顶部) -->
      <div
        class="flex flex-row md:flex-col justify-between md:justify-start w-full md:w-32 gap-4 order-1 md:order-1"
      >
        <!-- 分数板 -->
        <div
          class="bg-zinc-900 p-3 md:p-4 rounded-lg border border-zinc-700 w-1/2 md:w-full shadow-lg relative overflow-hidden"
        >
          <div
            class="absolute top-0 left-0 w-full h-1 bg-cyan-500 shadow-[0_0_10px_#06b6d4]"
          ></div>
          <div class="text-xs text-cyan-400 mb-1 tracking-wider">SCORE</div>
          <div id="score" class="text-xl md:text-2xl font-bold text-white">
            0
          </div>
          <div class="text-xs text-zinc-500 mt-2">
            HIGH: <span id="highScore">0</span>
          </div>
        </div>

        <!-- 等级/行数 -->
        <div
          class="bg-zinc-900 p-3 md:p-4 rounded-lg border border-zinc-700 w-1/2 md:w-full shadow-lg relative overflow-hidden"
        >
          <div
            class="absolute top-0 left-0 w-full h-1 bg-purple-500 shadow-[0_0_10px_#a855f7]"
          ></div>
          <div class="text-xs text-purple-400 mb-1 tracking-wider">LEVEL</div>
          <div id="level" class="text-xl md:text-2xl font-bold text-white">
            1
          </div>
          <div class="text-xs text-zinc-500 mt-2">
            LINES: <span id="lines">0</span>
          </div>
        </div>
      </div>

      <!-- 中间：游戏画布 -->
      <div
        class="relative order-2 md:order-2 neon-border bg-black rounded-sm shadow-2xl"
      >
        <canvas id="tetris" width="240" height="400" class="block"></canvas>

        <!-- 遮罩层 -->
        <div
          id="overlay"
          class="absolute inset-0 bg-black/85 flex flex-col items-center justify-center z-20"
        >
          <h1
            class="text-4xl md:text-5xl font-bold text-cyan-400 mb-2 tracking-tighter"
            style="text-shadow: 0 0 15px #06b6d4"
          >
            TETRIS
          </h1>
          <p
            id="gameOverText"
            class="text-red-500 text-xl mb-6 hidden font-bold tracking-widest animate-pulse"
          >
            GAME OVER
          </p>
          <button
            id="startBtn"
            class="px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded shadow-[0_0_15px_rgba(6,182,212,0.6)] transition-all transform hover:scale-105 active:scale-95"
          >
            START GAME
          </button>
          <p class="mt-4 text-[10px] text-zinc-500 md:block hidden">
            空格键直接下落
          </p>
        </div>
      </div>

      <!-- 右侧：下一个方块 (电脑端右侧，手机端绝对定位或隐藏) -->
      <div class="flex flex-col w-32 gap-4 order-3 md:order-3 hidden md:flex">
        <div
          class="bg-zinc-900 p-4 rounded-lg border border-zinc-700 aspect-square flex flex-col items-center justify-center relative overflow-hidden"
        >
          <div
            class="absolute top-0 left-0 w-full h-1 bg-yellow-500 shadow-[0_0_10px_#eab308]"
          ></div>
          <div class="text-xs text-yellow-400 mb-2 tracking-wider">NEXT</div>
          <canvas id="nextPiece" width="80" height="80"></canvas>
        </div>

        <div
          class="text-[10px] text-zinc-500 mt-auto border-t border-zinc-800 pt-2"
        >
          <p class="flex justify-between">
            <span>Move</span> <span class="text-zinc-300">← →</span>
          </p>
          <p class="flex justify-between">
            <span>Rotate</span> <span class="text-zinc-300">↑</span>
          </p>
          <p class="flex justify-between">
            <span>Soft</span> <span class="text-zinc-300">↓</span>
          </p>
          <p class="flex justify-between">
            <span>Hard</span> <span class="text-zinc-300">Space</span>
          </p>
        </div>
      </div>
    </div>

    <!-- 手机端虚拟按键 -->
    <div
      class="md:hidden grid grid-cols-4 gap-3 w-full max-w-[360px] px-4 pb-8 pt-2 z-20 mt-auto"
    >
      <!-- 左 -->
      <button class="control-btn h-16" id="btnLeft">
        <svg class="btn-icon" viewBox="0 0 24 24">
          <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
        </svg>
      </button>
      <!-- 下 -->
      <button class="control-btn h-16" id="btnDown">
        <svg class="btn-icon" viewBox="0 0 24 24">
          <path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" />
        </svg>
      </button>
      <!-- 右 -->
      <button class="control-btn h-16" id="btnRight">
        <svg class="btn-icon" viewBox="0 0 24 24">
          <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
        </svg>
      </button>
      <!-- 旋转/硬降 -->
      <div class="flex flex-col gap-2 h-16">
        <button
          class="control-btn flex-1 bg-cyan-900/30 border-cyan-500/30"
          id="btnRotate"
        >
          <svg class="btn-icon w-5 h-5" viewBox="0 0 24 24">
            <path
              d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"
            />
          </svg>
        </button>
        <button
          class="control-btn flex-1 bg-red-900/30 border-red-500/30"
          id="btnDrop"
        >
          <svg class="btn-icon w-5 h-5" viewBox="0 0 24 24">
            <path
              d="M19 15l-1.41-1.41L13 18.17V2h-2v16.17l-4.59-4.59L5 15l7 7 7-7z"
            />
          </svg>
        </button>
      </div>
    </div>

    <!-- 背景粒子装饰 -->
    <div
      class="absolute inset-0 overflow-hidden z-0 pointer-events-none opacity-20"
    >
      <div
        class="absolute top-[10%] left-[10%] w-64 h-64 bg-purple-600 rounded-full mix-blend-screen filter blur-[100px] animate-pulse"
      ></div>
      <div
        class="absolute bottom-[10%] right-[10%] w-64 h-64 bg-cyan-600 rounded-full mix-blend-screen filter blur-[100px] animate-pulse"
        style="animation-delay: 1s"
      ></div>
    </div>

    <script>
      // 使用 IIFE (立即执行函数) 来隔离作用域，防止重复声明错误
      (function () {
        const canvas = document.getElementById("tetris");
        const ctx = canvas.getContext("2d");
        const nextCanvas = document.getElementById("nextPiece");
        const nextCtx = nextCanvas.getContext("2d");

        const scoreEl = document.getElementById("score");
        const highScoreEl = document.getElementById("highScore");
        const linesEl = document.getElementById("lines");
        const levelEl = document.getElementById("level");
        const startBtn = document.getElementById("startBtn");
        const overlay = document.getElementById("overlay");
        const gameOverText = document.getElementById("gameOverText");

        // === 响应式缩放逻辑 ===
        let scale = 20;
        function resizeGame() {
          // 核心网格是 10列 x 20行
          const containerHeight = window.innerHeight * 0.6; // 留出空间给按钮
          const containerWidth = window.innerWidth * 0.9;

          // 计算最大可能的 scale
          const hScale = Math.floor(containerHeight / 20);
          const wScale = Math.floor(Math.min(containerWidth, 400) / 10);

          scale = Math.min(hScale, wScale, 30); // 最大30px
          if (scale < 15) scale = 15; // 最小15px

          canvas.width = 10 * scale;
          canvas.height = 20 * scale;

          // 如果游戏暂停或未开始，我们需要重绘一次背景
          if (!currentPiece) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          } else {
            draw();
          }
        }
        window.addEventListener("resize", resizeGame);

        // === 游戏常量 ===
        const ROW = 20;
        const COL = 10;
        const VACANT = "VACANT";

        // 方块定义
        const PIECES = [
          [Z, "#ef4444"], // Red
          [S, "#22c55e"], // Green
          [T, "#a855f7"], // Purple
          [O, "#eab308"], // Yellow
          [L, "#f97316"], // Orange
          [I, "#06b6d4"], // Cyan
          [J, "#3b82f6"] // Blue
        ];

        // 形状定义
        function I() {
          return [
            [0, 0, 0, 0],
            [1, 1, 1, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ];
        }
        function J() {
          return [
            [1, 0, 0],
            [1, 1, 1],
            [0, 0, 0]
          ];
        }
        function L() {
          return [
            [0, 0, 1],
            [1, 1, 1],
            [0, 0, 0]
          ];
        }
        function O() {
          return [
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
          ];
        }
        function S() {
          return [
            [0, 1, 1],
            [1, 1, 0],
            [0, 0, 0]
          ];
        }
        function T() {
          return [
            [0, 1, 0],
            [1, 1, 1],
            [0, 0, 0]
          ];
        }
        function Z() {
          return [
            [1, 1, 0],
            [0, 1, 1],
            [0, 0, 0]
          ];
        }

        // === 状态变量 ===
        let board = [];
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameOver = true;
        let dropStart = Date.now();
        let currentPiece; // 重命名 p -> currentPiece 以避免简短变量名冲突
        let nextPieceIdx;
        let animationId;
        let particles = [];

        // 初始化板子
        function createBoard() {
          for (let r = 0; r < ROW; r++) {
            board[r] = [];
            for (let c = 0; c < COL; c++) {
              board[r][c] = VACANT;
            }
          }
        }

        // 绘制方块单元格
        function drawSquare(x, y, color, context = ctx, s = scale) {
          if (color === VACANT) {
            return;
          }

          context.fillStyle = color;
          context.fillRect(x * s, y * s, s, s);

          // 内部高光 (Cyber style)
          context.fillStyle = "rgba(255,255,255,0.2)";
          context.fillRect(x * s + 2, y * s + 2, s - 4, s - 4);

          // 边框
          context.strokeStyle = "rgba(0,0,0,0.5)";
          context.lineWidth = 1;
          context.strokeRect(x * s, y * s, s, s);
        }

        // 绘制整个板子
        function drawBoard() {
          for (let r = 0; r < ROW; r++) {
            for (let c = 0; c < COL; c++) {
              drawSquare(c, r, board[r][c]);
            }
          }
        }

        // === 方块类 ===
        class Piece {
          constructor(tetromino, color) {
            this.tetromino = tetromino;
            this.color = color;
            this.tetrominoN = 0; // 旋转状态
            this.activeTetromino = this.tetromino;

            this.x = 3;
            this.y = -2; // 从上方看不见的地方开始
          }

          // 填充方法 (用于绘制和清除)
          fill(color) {
            for (let r = 0; r < this.activeTetromino.length; r++) {
              for (let c = 0; c < this.activeTetromino.length; c++) {
                if (this.activeTetromino[r][c]) {
                  drawSquare(this.x + c, this.y + r, color);
                }
              }
            }
          }

          draw() {
            this.fill(this.color);
          }

          unDraw() {
            // 每一帧重绘，不需要手动擦除
          }

          moveDown() {
            if (!this.collision(0, 1, this.activeTetromino)) {
              this.y++;
            } else {
              this.lock();
              if (!gameOver) {
                spawnNextPiece();
              }
            }
          }

          moveRight() {
            if (!this.collision(1, 0, this.activeTetromino)) {
              this.x++;
            }
          }

          moveLeft() {
            if (!this.collision(-1, 0, this.activeTetromino)) {
              this.x--;
            }
          }

          rotate() {
            let nextPattern = this.activeTetromino[0].map((val, index) =>
              this.activeTetromino.map((row) => row[index]).reverse()
            );

            // 简单的踢墙逻辑
            let kick = 0;
            if (this.collision(0, 0, nextPattern)) {
              if (this.x > COL / 2) kick = -1;
              else kick = 1;

              if (this.collision(kick, 0, nextPattern)) {
                return;
              }
            }

            this.x += kick;
            this.activeTetromino = nextPattern;
          }

          hardDrop() {
            while (!this.collision(0, 1, this.activeTetromino)) {
              this.y++;
            }
            this.lock();
            if (!gameOver) spawnNextPiece();
          }

          collision(x, y, piece) {
            for (let r = 0; r < piece.length; r++) {
              for (let c = 0; c < piece.length; c++) {
                if (!piece[r][c]) continue;

                let newX = this.x + c + x;
                let newY = this.y + r + y;

                if (newY < 0) continue;

                if (newX < 0 || newX >= COL || newY >= ROW) {
                  return true;
                }

                if (board[newY][newX] !== VACANT) {
                  return true;
                }
              }
            }
            return false;
          }

          lock() {
            for (let r = 0; r < this.activeTetromino.length; r++) {
              for (let c = 0; c < this.activeTetromino.length; c++) {
                if (!this.activeTetromino[r][c]) continue;

                // 游戏结束检测
                if (this.y + r < 0) {
                  setGameOver();
                  break;
                }

                board[this.y + r][this.x + c] = this.color;
              }
            }

            if (!gameOver) {
              // 消除行检测
              let rowCount = 0;
              for (let r = 0; r < ROW; r++) {
                let isRowFull = true;
                for (let c = 0; c < COL; c++) {
                  if (board[r][c] === VACANT) isRowFull = false;
                }

                if (isRowFull) {
                  createParticles(r);
                  // 消除并下沉
                  for (let y = r; y > 1; y--) {
                    for (let c = 0; c < COL; c++) {
                      board[y][c] = board[y - 1][c];
                    }
                  }
                  for (let c = 0; c < COL; c++) {
                    board[0][c] = VACANT;
                  }
                  rowCount++;
                }
              }

              if (rowCount > 0) updateScore(rowCount);
            }
          }
        }

        // === 游戏流程控制 ===

        function spawnNextPiece() {
          if (nextPieceIdx === undefined) {
            nextPieceIdx = Math.floor(Math.random() * PIECES.length);
          }

          // 当前方块 = 之前的 Next
          const currentIdx = nextPieceIdx;
          currentPiece = new Piece(
            PIECES[currentIdx][0](),
            PIECES[currentIdx][1]
          );

          // 生成新的 Next
          nextPieceIdx = Math.floor(Math.random() * PIECES.length);
          drawNextPiece(nextPieceIdx);
        }

        function drawNextPiece(idx) {
          const shape = PIECES[idx][0]();
          const color = PIECES[idx][1];

          nextCtx.fillStyle = "#09090b";
          nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

          const previewScale = 18;
          // 计算居中偏移
          const w = shape[0].length * previewScale;
          const h = shape.length * previewScale;
          const offsetX = (80 - w) / 2;
          const offsetY = (80 - h) / 2;

          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
              if (shape[r][c]) {
                nextCtx.fillStyle = color;
                nextCtx.fillRect(
                  offsetX + c * previewScale,
                  offsetY + r * previewScale,
                  previewScale - 2,
                  previewScale - 2
                );
                nextCtx.fillStyle = "rgba(255,255,255,0.3)";
                nextCtx.fillRect(
                  offsetX + c * previewScale + 2,
                  offsetY + r * previewScale + 2,
                  previewScale - 6,
                  previewScale - 6
                );
              }
            }
          }
        }

        function updateScore(rows) {
          const points = [0, 100, 300, 500, 800];
          score += points[rows] * level;
          lines += rows;
          level = Math.floor(lines / 10) + 1;

          scoreEl.innerText = score;
          linesEl.innerText = lines;
          levelEl.innerText = level;

          if (rows >= 4) {
            document.body.classList.add("shake-screen");
            setTimeout(
              () => document.body.classList.remove("shake-screen"),
              300
            );
          }

          const hs = localStorage.getItem("tetrisHighScore") || 0;
          if (score > hs) {
            localStorage.setItem("tetrisHighScore", score);
            highScoreEl.innerText = score;
          }
        }

        function createParticles(row) {
          const y = row * scale + scale / 2;
          for (let i = 0; i < 25; i++) {
            particles.push({
              x: Math.random() * canvas.width,
              y: y + (Math.random() * scale - scale / 2),
              vx: (Math.random() - 0.5) * 15,
              vy: (Math.random() - 0.5) * 15,
              life: 1.0,
              color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
          }
        }

        function drawParticles() {
          for (let i = particles.length - 1; i >= 0; i--) {
            let pt = particles[i];
            ctx.fillStyle = pt.color;
            ctx.globalAlpha = pt.life;
            ctx.fillRect(pt.x, pt.y, 3, 3);
            ctx.globalAlpha = 1.0;

            pt.x += pt.vx;
            pt.y += pt.vy;
            pt.life -= 0.04;

            if (pt.life <= 0) particles.splice(i, 1);
          }
        }

        function setGameOver() {
          gameOver = true;
          document.getElementById("gameOverText").classList.remove("hidden");
          startBtn.innerText = "TRY AGAIN";
          overlay.classList.remove("hidden");
        }

        // === 主循环 ===
        function update() {
          if (gameOver) return;

          let now = Date.now();
          let delta = now - dropStart;

          // 速度随等级增加
          let speed = Math.max(100, 800 - (level - 1) * 50);

          if (delta > speed) {
            currentPiece.moveDown();
            dropStart = Date.now();
          }

          draw();

          animationId = requestAnimationFrame(update);
        }

        function draw() {
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          drawBoard();
          if (currentPiece) currentPiece.draw();
          drawParticles();
        }

        // === 输入控制 ===
        document.addEventListener("keydown", (event) => {
          if (gameOver || !currentPiece) return;

          if (event.keyCode == 37) {
            // Left
            currentPiece.moveLeft();
            draw();
          } else if (event.keyCode == 38) {
            // Up (Rotate)
            currentPiece.rotate();
            draw();
          } else if (event.keyCode == 39) {
            // Right
            currentPiece.moveRight();
            draw();
          } else if (event.keyCode == 40) {
            // Down
            currentPiece.moveDown();
            draw();
          } else if (event.keyCode == 32) {
            // Space
            event.preventDefault();
            currentPiece.hardDrop();
            draw();
          }
        });

        // 虚拟按键绑定
        const setupBtn = (id, action) => {
          const btn = document.getElementById(id);
          if (!btn) return;

          const trigger = (e) => {
            if (e.cancelable) e.preventDefault();
            if (!currentPiece || gameOver) return;
            action();
            draw();
          };

          btn.addEventListener("touchstart", trigger, { passive: false });
          btn.addEventListener("mousedown", trigger);
        };

        setupBtn("btnLeft", () => currentPiece.moveLeft());
        setupBtn("btnRight", () => currentPiece.moveRight());
        setupBtn("btnRotate", () => currentPiece.rotate());
        setupBtn("btnDown", () => currentPiece.moveDown());
        setupBtn("btnDrop", () => currentPiece.hardDrop());

        // 开始按钮逻辑
        startBtn.addEventListener("click", () => {
          // 重置状态
          createBoard();
          resizeGame();
          gameOver = false;
          score = 0;
          lines = 0;
          level = 1;
          scoreEl.innerText = 0;
          linesEl.innerText = 0;
          levelEl.innerText = 1;
          particles = [];
          nextPieceIdx = undefined;

          highScoreEl.innerText = localStorage.getItem("tetrisHighScore") || 0;
          overlay.classList.add("hidden");
          gameOverText.classList.add("hidden");

          spawnNextPiece();
          dropStart = Date.now();

          if (animationId) cancelAnimationFrame(animationId);
          update();
        });

        // 初始化显示
        highScoreEl.innerText = localStorage.getItem("tetrisHighScore") || 0;
        resizeGame();
      })(); // 立即执行函数结束
    </script>
  </body>
</html>
